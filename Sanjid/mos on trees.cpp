struct Query {  ll id, l, r, bno,k;  };  //basic comparator  bool cmp(Query &a,Query &b) {  if (a.bno != b.bno) {  return a.bno < b.bno;  } else if (a.bno & 1) {  return a.r < b.r;  } else {  return a.r > b.r;  }  }  ll n,q;  ll bs=700;// change is depending on problem  Query qry[N];  ll a[N],b[N],st[N],en[N];  ll ans[N];  ll tt = -1;  vll g[N];  void gg(ll x, ll pr){  //trc(x);  tt++;  st[x] = tt;  a[tt] = x;  //trc(tt,a[tt]);  go(i,g[x]){  if(i == pr) cu;  gg(i,x);  }  tt++;  en[x] = tt;  a[tt] = x;  }  const ll LG = 30;  ll tim=0;  ll parent[LG][N];  ll tin[N], tout[N], level[N];  void dfs(ll k, ll par, ll lvl)  {  tin[k]=++tim;  parent[0][k]=par;  level[k]=lvl;  for(auto it:g[k])  {  if(it==par)  continue;  dfs(it, k, lvl+1);  }  tout[k]=tim;  }  ll walk(ll u, ll h)  {  for(ll i=LG-1;i>=0;i--)  {  if((h>>i) & 1)  u = parent[i][u];  }  return u;  }  void precompute()  {  for(ll i=1;i<LG;i++)  for(ll j=1;j<=n;j++)  if(parent[i-1][j])  parent[i][j]=parent[i-1][parent[i-1][j]];  }  ll lca(ll u, ll v)  {  if(level[u]<level[v])  swap(u,v);  ll diff=level[u]-level[v];  for(ll i=LG-1;i>=0;i--)  {  if((1<<i) & diff)  {  u=parent[i][u];  }  }  if(u==v)  return u;  for(ll i=LG-1;i>=0;i--)  {  if(parent[i][u] && parent[i][u]!=parent[i][v])  {  u=parent[i][u];  v=parent[i][v];  }  }  return parent[0][u];  }  ll dist(ll u, ll v)  {  return level[u] + level[v] - 2 * level[lca(u, v)];  }  ll lp,rp,cnt;  ll freq[1000001];  ll freq2[1000005];  //unordered_map<ll,ll>freq,freq2;  void add(ll val) {  freq[val]++;  freq2[b[val]]++;  if(freq[val] == 2){  freq2[b[val]]-=2;  // if(freq2[b[val]] == 0){  //     cnt--;  // }  }  else{  // if(freq2[b[val]] == 1) cnt++;  }  }  void remove(ll val) {  freq[val]--;  freq2[b[val]]--;  if(freq[val] == 1){  freq2[b[val]]+=2;  // if(freq2[b[val]] == 1){  //     cnt++;  // }  }  else{  // if(freq2[b[val]] == 0) cnt--;  }  }  ll get_answer() {  return cnt;  }  void solve() {  cin >> n>>q;  //trc(n,q);  mll m;  ll dd = 0;  for (ll i = 1; i <= n; i++) {  cin >> b[i];  if(!m.count(b[i])){  m[b[i]] = dd++;  }  b[i] = m[b[i]];  }  f0(n-1){  ipp(x,y);  //trc(x,y);  g[x].pb(y);  g[y].pb(x);  }  gg(1,0);  dfs(1,0,0);  precompute();  for (ll i = 0; i < q; i++) {  ll x, y;  cin >> x >> y;  if(level[x]>level[y]){  swap(x,y);  }  ll p = lca(x,y);  // trc(x,y,p);  ll l,r;  if(p == x){  l = st[x];  r = st[y];  qry[i].k = -1;  }  else{  if(st[x]>st[y]) swap(x,y);  l = en[x];  r = st[y];  qry[i].k = st[p];  // trc(l,r,p,st[p]);  // f(j,l,r+1){  //     trc(j,a[j]);  // }  }  qry[i].id = i;  qry[i].l = l;  qry[i].r = r;  qry[i].bno = l / bs;  }  // sort the queries  sort(qry, qry + q, cmp);  // initialise the data-structure  lp = 0;  rp = -1;  cnt = 0;  // add(a[0]);  // answer the queries  for (ll i = 0; i < q; i++) {  ll l = qry[i].l;  ll r = qry[i].r;  while (rp < r) {  add(a[++rp]);  }  while (lp > l) {  add(a[--lp]);  }  while (rp > r) {  remove(a[rp--]);  }  while (lp < l) {  remove(a[lp++]);  }  ans[qry[i].id] = get_answer();  if(qry[i].k != -1){  // if(freq2[b[a[qry[i].k]]] == 0){  //     ans[qry[i].id]++;  // }  }  }  for (ll i = 0; i < q; i++) {  cout << ans[i] << endl;  }  }  // this require the element to be added on both side l,r and removed l,r  // but we can also use mo's when data structure allow the removal from the side where we added like rollback dsu  void fun()  {  solve();  }  int32_t main()  {  // tasklist  // taskkill /f /im a.exe  depressed();  ll tc1 = 1;  //cin>>tc1;  while(tc1--)  {  fun();  }  //cer;  return 0;  }